package edu.iastate.cs228.hw04;/** *  * @author Sam Shifflett *  * NOTE:  * 0. Put your Firstname and Lastname after above author tag. * 	  Make sure that in both cases the first letter is uppercase *    and all others are lowercase (and a space). * 1. You are allowed to create and use your own private helper methods.  * 2. No additional data fields can be introduced. * 3. No custom classes of your own can be introduced or used. * 4. Import statements are not allowed. * 5. Fully qualified class names usage is not allowed. * 6. You are allowed to reuse any part of the source codes provided *    or shown in lecture notes of week 5 (or before). * 7. You are not allowed to create arrays of objects and manipulate *    queue objects using arrays.  * * * DESCRIPTION: * A class that implements the ADT deque by using a "circular doubly linked chain" of  * nodes. In doubly linked chain, the first and last nodes each contain one null  * reference, since the first node has no previous node and the last node has no node  * after it. (For details of doubly linked chain implementation of deque, check slide  * number 3 of "queueDequePriorityQueueImplementations_part3.pdf" file under lecture  * notes of Friday of Week 5 on Canvas.) In a "circular doubly linked chain", the first * node references the last node, and the last node references the first. Only one * external reference is necessary - a reference to the first node - since you can * quickly get to the last node from the first node.  *  */public class CircularDoublyLinkedDeque<T> implements DequeInterface<T> {	private DLNode firstNode; // References node for front of deque	public CircularDoublyLinkedDeque() 	{		firstNode = null;	} // end default constructor	public void addToBack(T newEntry) 	{		DLNode newNode;				if(firstNode == null)		{			firstNode = new DLNode(null,newEntry,null);		}		else		{			if(firstNode.next == null)			{				newNode = new DLNode(firstNode,newEntry,firstNode);				firstNode.next = newNode;				firstNode.previous = newNode;			}			else			{				newNode = new DLNode(firstNode,newEntry,firstNode.next);				firstNode.next = newNode;			}		}		return;	}	public void addToFront(T newEntry) 	{		DLNode newNode;				if(firstNode == null)		{			firstNode = new DLNode(null,newEntry,null);		}		else		{			if(firstNode.next == null)			{				newNode = new DLNode(firstNode,newEntry,firstNode);				firstNode.next = newNode;				firstNode.previous = newNode;				firstNode = newNode;			}			else			{				newNode = new DLNode(firstNode,newEntry,firstNode.next);				firstNode = newNode;			}		}		return;	}	public T getFront() 	{		if(firstNode == null)		{			throw new EmptyQueueException();		}		return firstNode.getData();	}	public T getBack() 	{		if(firstNode == null)		{			throw new EmptyQueueException();		}		else if(firstNode.next == null && firstNode.data != null)		{			return firstNode.data;		}		else		{			return firstNode.getNextNode().getData();		}	}	public T removeFront() 	{		T frontData;				if(firstNode == null)		{			throw new EmptyQueueException();		}		else		{			if(firstNode.next == null)			{				frontData = firstNode.data;				firstNode = null;			}			else			{				frontData = firstNode.data;				firstNode.next.previous = firstNode.previous;				firstNode.previous.next = firstNode.next;				firstNode = firstNode.previous;			}		}				return frontData;	}	public T removeBack() 	{		T backData;				if(firstNode == null)		{			throw new EmptyQueueException();		}		else		{			if(firstNode.next == null)			{				backData = firstNode.data;				firstNode = null;			}			else			{				backData = firstNode.next.data;				firstNode.next.next.previous = firstNode;				firstNode.next = firstNode.next.next;			}		}				return backData;	}	public void clear() 	{		firstNode = null;		return;	}	public boolean isEmpty() 	{		return (firstNode == null);	}		private class DLNode	{		private T      data;  	 // Deque entry		private DLNode next;  	 // Link to next node		private DLNode previous; // Link to previous node		private DLNode()		{			this(null, null, null);		} // end default constructor		private DLNode(T dataPortion)		{			this(null, dataPortion, null);		} // end constructor		private DLNode(DLNode previousNode, T dataPortion, DLNode nextNode)		{			data = dataPortion;			next = nextNode;				previous = previousNode;		} // end constructor		private T getData()		{			return data;		} // end getData		private void setData(T newData)		{			data = newData;		} // end setData		private DLNode getNextNode()		{			return next;		} // end getNextNode		private void setNextNode(DLNode nextNode)		{			next = nextNode;		} // end setNextNode		private DLNode getPreviousNode()		{			return previous;		} // end getPreviousNode		private void setPreviousNode(DLNode previousNode)		{			previous = previousNode;		} // end setPreviousNode	} // end DLNode} // end CircularDoublyLinkedDeque