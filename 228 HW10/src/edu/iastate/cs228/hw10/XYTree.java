package edu.iastate.cs228.hw10;import java.util.LinkedList;/** * A class that implements an xy-tree. *  * @author Sam Shifflett *  *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{  private BinaryNode<T> root;  public XYTree()  {	root = null;  }  public XYTree(T rootData)  {	if (rootData != null)	  root = new BinaryNode<>(rootData);	else	  throw new IllegalArgumentException();  }  public void addAllPoints(T[] entries)  {	if (entries == null || entries.length == 0)	  throw new IllegalArgumentException();	for (T t : entries)	  addPoint(t);  }  /**   *   * Adds a new point into the xy-tree if it does not    * exist in this tree. Check an example under Canvas.   * Also, check the comment of levelOrderTraverse.   *    */  public void addPoint(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();		addPointRec(anEntry,root);		return;  }      /*   * @param anEntry the Data that should be put into the Node if we dictate a place to put it   * @param tempNode the Node to do conditional assesment on in order to either   * add or call the recursive add method on one of the children   */  private void addPointRec(T anEntry, BinaryNode tempNode)  {	  if(tempNode == null)	  {		  root = new BinaryNode<T>(anEntry);		  return;	  }	  	  BinaryNode temp = tempNode;			  T tempData = (T)temp.getData();	  	  if(anEntry.getX() < tempData.getX())	  {		  if(temp.hasLeftChild())		  {			  addPointRec(anEntry,temp.getLeftChild());		  }		  else		  {			  BinaryNode<T> addNode = new BinaryNode<T>(anEntry);			  temp.setLeftChild(addNode);			  return;		  }		  return;	  }	  if(anEntry.getX() > tempData.getX())	  {		  if(temp.hasRightChild())		  {			  addPointRec(anEntry,temp.getRightChild());		  }		  else		  {			  BinaryNode<T> addNode = new BinaryNode<T>(anEntry);			  temp.setRightChild(addNode);			  return;		  }		  return;	  }	  if(anEntry.getX() == tempData.getX())	  {		  if(anEntry.getY() < tempData.getY())		  {			  if(temp.hasLeftChild())			  {				  addPointRec(anEntry,temp.getLeftChild());			  }			  else			  {				  BinaryNode<T> addNode = new BinaryNode<T>(anEntry);				  temp.setLeftChild(addNode);				  return;			  }			  return;		  }		  if(anEntry.getY() > tempData.getY())		  {			  if(temp.hasRightChild())			  {				  addPointRec(anEntry,temp.getRightChild());			  }			  else			  {				  BinaryNode<T> addNode = new BinaryNode<T>(anEntry);				  temp.setRightChild(addNode);				  return;			  }			  return;		  }		  if(anEntry.getY() == tempData.getY())		  {			  return;		  }	  }	    }  /**   * Returns true if a point exists in this tree,    * otherwise false.   *    */  public boolean contains(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();		return containsRec(anEntry,root);  }    private boolean containsRec(T anEntry, BinaryNode<T> tempNode)  {	  if(tempNode == null)	  {		  return false;	  }	  	  BinaryNode<T> temp = tempNode;			  T tempData = (T)temp.getData();	  	  if(anEntry.getX() < tempData.getX())	  {		  if(temp.hasLeftChild())		  {			  return containsRec(anEntry,temp.getLeftChild());		  }		  else			  return false;	  }	  if(anEntry.getX() > tempData.getX())	  {		  if(temp.hasRightChild())		  {			  return containsRec(anEntry,temp.getRightChild());		  }		  else			  return false;	  }	  if(anEntry.getX() == tempData.getX())	  {		  if(anEntry.getY() < tempData.getY())		  {			  if(temp.hasLeftChild())			  {				  return containsRec(anEntry,temp.getLeftChild());			  }			  else				  return false;		  }		  if(anEntry.getY() > tempData.getY())		  {			  if(temp.hasRightChild())			  {				  return containsRec(anEntry,temp.getRightChild());			  }			  else				  return false;		  }		  if(anEntry.getY() == tempData.getY())		  {			  return true;		  }	  }	  return false;  }  /**   * Returns a list of points in level-order traversal.    * In this method you are allowed to use    * java.util.LinkedList class.   *    *    * For example,   *    * XYTree<Point> xy = new XYTree<>();    *    * xy.addAllPoints(new Point[]{   * 	new Point(5, 3),    *    new Point(5, 2),    *    new Point(10, 7),    *    new Point(9, 1),    *    new Point(6, 8),    *    new Point(6, 8),    *    new Point(10, 1)   * });   * System.out.println(xy.levelOrderTraverse());   *    * would print   *    * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]   *    */  public java.util.LinkedList<String> levelOrderTraverse()  {	  LinkedList<BinaryNode<T>> tempList = new LinkedList();	  LinkedList<String> tempStringList = new LinkedList<String>();	  	  tempList = levelOrderTraverseLL(root,tempList);	  	  for(int i = 0; i < tempList.size(); i++)	  {		  T tempData = tempList.get(i).getData();		  String tempString = String.valueOf(tempData);		  tempStringList.add("(" + (int)tempData.getX() + ", " + (int)tempData.getY() + ")");	  }	  	return tempStringList;  }    private java.util.LinkedList<BinaryNode<T>> levelOrderTraverseLL(BinaryNode<T> temp, LinkedList<BinaryNode<T>> tempList)  {	  LinkedList<BinaryNode<T>> tempList2 = new LinkedList();	   if(temp.equals(null))		   return null;	   	   tempList.add(temp);	   	   while(true)	   {		   int nodeCount = tempList.size();		   		   if(nodeCount == 0)			   break;		   		   while(nodeCount > 0)		   {			   BinaryNode<T> tempNode = tempList.removeFirst();			   tempList2.add(tempNode);			   if(tempNode.hasLeftChild())			   {				   tempList.add(tempNode.getLeftChild());			   }			   if(tempNode.hasRightChild())			   {				   tempList.add(tempNode.getRightChild());			   }			   nodeCount--;		   }	   }	   return tempList2;  }  @Override  @SuppressWarnings("unchecked")  public T getRootData()  {	if (isEmpty())	  throw new RuntimeException("Empty Tree!");	else	  return (T) root.getData().clone();  }  @Override  public boolean isEmpty()  {	return root == null;  }  @Override  public void clear()  {	root = null;  }  @Override  public int getHeight()  {	return root.getHeight();  }  @Override  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  }}